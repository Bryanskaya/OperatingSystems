# 1 программа (сокеты в файловом пространстве имён)
> используют в качестве адресов имена файлов специального типа
> Важной особенностью сокетов в файловом пространстве имён является то, что соединение с их помощью локального и удаленного приложений невозможно, даже если файловая система, в которой создан сокет, доступна удаленной операционной системе.
* Сокеты в программах представлены дескрипторами
---


## struct sockaddr
- используется для хранения адресов
```c
struct sockaddr 
{ 
       unsigned short sa_family; // Семейство адресов, AF_xxx 
       char sa_data[14]; // 14 байтов для хранения адреса 
};
```
## int socket (int domain, int type, int protocol);
> sock = socket(AF_INET, SOCK_STREAM, 0);

1. В нашем случае 1 параметр, домен = **AF_UNIX**
> Домен, обозначенный константой AF_UNIX, соответствует сокетам в файловом пространстве имен (cемейство сокетов AF_UNIX используется для взаимодействия между процессами на **одной** машине). 
2. 2 параметр - **тип сокета**. 
* SOCK_DGRAM (**датаграмный сокет**) - допустимый тип сокеты в UNIX, использует "User Datagram Protocol", или "UDP" (не гарантируется, что пакеты будут доставлены в порядке поступления и вообще будут ли доставлены)
* SOCK_STREAM - гарантируется доставка байт в порядке поступления; пока непрерывный поток байтов не прекратится, никакие другие данные приниматься каналом не будут (аналогом такой связи является pipe-механизм)
* SOCK_RAW - простой или символьный сокет.
3. 3 параметр - **протокол**, используемый для передачи данных. 0 = протокол не указан, используется значение по умолчанию для данного вида соединений. 

Возвращает целое положительное число - **номер дескриптора сокета** (то есть создается дескриптор сокета)

## ssize_t sendto(int sockfd, const void * buf, size_t len, int flags, const struct sockaddr * dest_addr, socklen_t addrlen);
- отправляют данные в сокет
> err = sendto(sock, buf, strlen(buf), 0, &srvr_name, sizeof(srvr_name));  

1 параметр - дескриптор сокета  
2 параметр - адрес буфера для передачи данных  
3 параметр - длина буфера  
4 параметр - дополнительных флагов  
> ПРОСТО ДЛЯ ОЗНАКОМЛЕНИЯ  
>> может принимать значения:  
>> MSG_CONFIRM - Сообщить уровню связи, что процесс пересылки произошел: получен успешный ответ с другой стороны. Если уровень связи не получит его, то он будет регулярно перепроверять наличие ответной стороны.  
>> MSG_DONTROUTE - Не использовать маршрутизацию для отправки пакета, а посылать его только на узлы локальной сети. Обычно это используется в диагностических программах и программах маршрутизации.  
>> MSG_DONTWAIT - Включить неблокирующий режим.  
>> MSG_EOR - Завершить запись (record)  
>> MSG_MORE - Дополнительные данные для отправки.  
>> MSG_NOSIGNAL - Не генерировать сигнал SIGPIPE, если сторона потокоориентированного сокета закрыла соединение.  
>> MSG_OOB - Послать внепоточные данные, если сокет это поддерживает.  

5 параметр - Адрес сервера  
6 параметр - Длина адреса сервера  

При успешном выполнении эти вызовы возвращают количество отправленных байт

```
Перед вызовом функции sendto() надо заполнить структуру sockaddr (переменную srvr_name) данными об адресе сервера.  
После окончания передачи данных сокет закрывается с помощью close().
```

## int bind(int sockfd, struct sockaddr * my_addr, socklen_t addrlen);
- связывает сокет с заданным адресом (**связывать сокет с адресом необходимо в программе-сервере, но не в клиенте**)  
> bind(sock, &srvr_name, sizeof(srvr_name)) 

1 параметр - дескриптор сокета  
2 параметр - указатель на структуру sockaddr (переменная srvr_name), содержащую адрес, на котором регистрируется сервер  
3 параметр - длина структуры, содержащей адрес  

## int recvfrom(int s, void * buf, size_t len, int flags, struct sockaddr * from, socklen_t * fromlen);
- принимает данные из сокета (**по умолчанию блокирует программу до тех пор, пока на входе не появятся новые данные**)
> len = recvfrom(sock, buf, sizeof(buf), 0, NULL, NULL);

1 параметр - дескриптор сокета  
2 параметр - указатель на буфер, из которого будет производится чтение
3 параметр - число байт для чтения/записи
4 параметр -  флаги (если не нужны, то 0)
> ПРОСТО ДЛЯ ОЗНАКОМЛЕНИЯ  
>> может принимать значения:  
>> MSG_OOB запрашивает прием внепотоковых данных, которые в противном случае не были бы получены в обычном потоке данных.     
>> MSG_PEEK - выбрать данные из начала очереди, но не удалять их оттуда. Таким образом, последующий вызов функции вернет те же самые данные.   
>> MSG_WAITALL - подождать, пока не придет полное запрошенное количество данных. Однако, этот вызов все равно может вернуть меньше данных, чем было запрошено, если был пойман сигнал, произошла ошибка или разрыв соединения, или если начали поступать данные другого типа, не того, который был сначала.   
>> MSG_TRUNC - реальная длину пакета, даже если она была больше, чем предоставленный буфер.   
>> MSG_ERRQUEUE - Получить пакет из очереди ошибок.    
>> MSG_NOSIGNAL отключает возникновение сигнала SIGPIPE на потоковых сокетах, если другая сторона вдруг исчезает.  
>> MSG_ERRQUEUE - получить из очереди ошибок сокета накопившиеся ошибки.   
5 параметр -  адрес
6 параметр - указатель на переменную, в которой будет возвращена длина структуры с адресом
```
Если информация об адресе клиента не нужна, то можно передать значения NULL в предпоследнем и последнем параметрах
```

Возвращает количество принятых байт

## close & unlink
- По завершении работы с сокетом он «закрывается» с помощью «файловой» функции **close()**.  
- Перед выходом из программы-сервера следует удалить файл сокета, созданный в результате вызова socket(), что  делается с помощью функции unlink().


# 2 программа (я так думаю, на сетевые сокеты)
## struct hostent * server;
- содержит имя сервера в приемлемом для дальнейшего использования виде  
```c
struct hostent 
{
	char FAR * h_name;			// имя хоста
	char FAR * FAR * h_aliases;		// дополнительные названия
	short h_addrtype;			// тип адреса
	short h_length;			// длинна каждого адреса в байтах
	char FAR * FAR * h_addr_list;	// список адресов
};
```

##  struct sockaddr_in
- Для сетевого взаимодействия
```c
struct sockaddr_in
 { 
    short int sin_family; // Семейство адресов
    unsigned short int sin_port; // Номер порта
    struct in_addr sin_addr; // IP-адрес
    unsigned char sin_zero[8]; // Дополнение до размера структуры sockaddr
 };
```
## struct hostent * gethostbyname(const char * name);
- получает указатель на строку с Интернет-именем сервера (например, www.unix.com или 192.168.1.16)
- возвращает указатель на структуру hostent, которая содержит имя сервера в приемлемом для дальнейшего использования виде

## int connect(int sockfd, const struct sockaddr * serv_addr, socklen_t addrlen);  
- для установки соединения
1 параметр - дескриптор сокета  
> Если сокет имеет тип SOCK_DGRAM, адрес serv_addr является адресом по умолчанию, куда посылаются датаграммы, и единственным адресом, откуда они принимаются. Если сокет имеет тип SOCK_STREAM, то данный системный вызов попытается установить соединение с другим сокетом.
2 параметр - адрес, на который он ссылается   
3 параметр - длина адреса  

Если успешно, возвращается ноль.  

## ssize_t send(int s, const void * msg, size_t len, int flags);
- отправляет данные в сокет  
1 параметр - дескриптор сокета  
2 параметр - адрес буфера для передачи данных  
3 параметр - длина буфера  
4 параметр - дополнительных флагов  

Возвращает количество отправленных символов
