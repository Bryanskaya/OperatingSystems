# 1 программа (сокеты в файловом пространстве имён)
> используют в качестве адресов имена файлов специального типа
> Важной особенностью сокетов в файловом пространстве имён является то, что соединение с их помощью локального и удаленного приложений невозможно, даже если файловая система, в которой создан сокет, доступна удаленной операционной системе.
## 

* Сокеты в программах представлены дескрипторами




## struct sockaddr
- используется для хранения адресов
```c
struct sockaddr 
{ 
       unsigned short sa_family; // Семейство адресов, AF_xxx 
       char sa_data[14]; // 14 байтов для хранения адреса 
};
```
## int socket (int domain, int type, int protocol);
1. В нашем случае 1 параметр, домен = **AF_UNIX**
> Домен, обозначенный константой AF_UNIX, соответствует сокетам в файловом пространстве имен (cемейство сокетов AF_UNIX используется для взаимодействия между процессами на **одной** машине). 
2. 2 параметр - **тип сокета**. 
* SOCK_DGRAM (**датаграмный сокет**) - допустимый тип сокеты в UNIX, использует "User Datagram Protocol", или "UDP" (не гарантируется, что пакеты будут доставлены в порядке поступления и вообще будут ли доставлены)
* SOCK_STREAM - гарантируется доставка байт в порядке поступления; пока непрерывный поток байтов не прекратится, никакие другие данные приниматься каналом не будут (аналогом такой связи является pipe-механизм)
* SOCK_RAW - простой или символьный сокет.
3. 3 параметр - **протокол**, используемый для передачи данных. 0 = протокол не указан, используется значение по умолчанию для данного вида соединений. 

Возвращает целое положительное число - **номер дескриптора сокета** (то есть создается дескриптор сокета)

## ssize_t sendto(int sockfd, const void * buf, size_t len, int flags, const struct sockaddr * dest_addr, socklen_t addrlen);
> отправляют данные в сокет
> err = sendto(sock, buf, strlen(buf), 0, &srvr_name, sizeof(srvr_name));
1. 1 параметр - дескриптор сокета
2. 2 параметр - адрес буфера для передачи данных
3. 3 параметр - длина буфера
4. 4 параметр - дополнительных флагов
>> может принимать значения:
>> MSG_CONFIRM - Сообщить уровню связи, что процесс пересылки произошел: получен успешный ответ с другой стороны. Если уровень связи не получит его, то он будет регулярно перепроверять наличие ответной стороны.
>> MSG_DONTROUTE - Не использовать маршрутизацию для отправки пакета, а посылать его только на узлы локальной сети. Обычно это используется в диагностических программах и программах маршрутизации.
>> MSG_DONTWAIT - 
Включить неблокирующий режим. Если операция могла бы привести к блокировке, возвращается EAGAIN или EWOULDBLOCK. Такое поведение подобно заданию флага O_NONBLOCK (в fcntl(2) операцией F_SETFL), но отличие в том, что MSG_DONTWAIT указывается в вызове, а O_NONBLOCK задаётся в описании открытого файла (смотрите open(2)), что влияет на все нити вызывающего процесса, а также на другие процессы, у которых есть файловые дескрипторы, ссылающиеся на это описание открытого файла.
MSG_EOR (начиная с Linux 2.2)
Завершить запись (record) (если поддерживается, например в сокетах типа SOCK_SEQPACKET).
MSG_MORE (начиная с Linux 2.4.4)
Вызывающий имеет дополнительные данные для отправки. Этот флаг используется с сокетами TCP для получения такого же эффекта как с параметром сокета TCP_CORK (см. tcp(7)), с той разницей, что этот флаг можно устанавливать при каждом вызове.
Начиная с Linux 2.6 этот флаг также поддерживается для сокетов UDP и информирует ядро, о том что нужно упаковать все отправляемые данные вызовов с этим флагом в одну дейтаграмму, которая передаётся только когда выполняется вызов без указания этого флага (смотрите также описание параметра сокета UDP_CORK в udp(7)).

MSG_NOSIGNAL (начиная с Linux 2.2)
Не генерировать сигнал SIGPIPE, если сторона потокоориентированного сокета закрыла соединение. Ошибка EPIPE по прежнему возвращается. Это создаёт поведение как при использовании sigaction(2) для игнорирования SIGPIPE, но MSG_NOSIGNAL является свойством вызова, а установка SIGPIPE в атрибутах процесса влияет на все нити процесса.
MSG_OOB
Послать внепоточные данные, если сокет это поддерживает (как, например, сокеты типа SOCK_STREAM); протокол более низкого уровня также должен поддерживать внепоточные данные.
6. 
