# 1 программа (сокеты в файловом пространстве имён)
> используют в качестве адресов имена файлов специального типа
> Важной особенностью сокетов в файловом пространстве имён является то, что соединение с их помощью локального и удаленного приложений невозможно, даже если файловая система, в которой создан сокет, доступна удаленной операционной системе.
* Сокеты в программах представлены дескрипторами
---


## struct sockaddr
- используется для хранения адресов
```c
struct sockaddr 
{ 
       unsigned short sa_family; // Семейство адресов, AF_xxx 
       char sa_data[14]; // 14 байтов для хранения адреса 
};
```
## int socket (int domain, int type, int protocol);
> sock = socket(AF_INET, SOCK_STREAM, 0);

1. В нашем случае 1 параметр, домен = **AF_UNIX**
> Домен, обозначенный константой AF_UNIX, соответствует сокетам в файловом пространстве имен (cемейство сокетов AF_UNIX используется для взаимодействия между процессами на **одной** машине). 
> AF_INET - открываемый сокет должен быть сетевым  
2. 2 параметр - **тип сокета**. 
* SOCK_DGRAM (**датаграмный сокет**) - допустимый тип сокеты в UNIX, использует "User Datagram Protocol", или "UDP" (не гарантируется, что пакеты будут доставлены в порядке поступления и вообще будут ли доставлены)
* SOCK_STREAM - гарантируется доставка байт в порядке поступления; пока непрерывный поток байтов не прекратится, никакие другие данные приниматься каналом не будут (аналогом такой связи является pipe-механизм)
* SOCK_RAW - простой или символьный сокет.
3. 3 параметр - **протокол**, используемый для передачи данных. 0 = протокол не указан, используется значение по умолчанию для данного вида соединений. 

Возвращает целое положительное число - **номер дескриптора сокета** (то есть создается дескриптор сокета)

## ssize_t sendto(int sockfd, const void * buf, size_t len, int flags, const struct sockaddr * dest_addr, socklen_t addrlen);
- отправляют данные в сокет
> err = sendto(sock, buf, strlen(buf), 0, &srvr_name, sizeof(srvr_name));  

1 параметр - дескриптор сокета  
2 параметр - адрес буфера для передачи данных  
3 параметр - длина буфера  
4 параметр - дополнительных флагов  
> ПРОСТО ДЛЯ ОЗНАКОМЛЕНИЯ  
>> может принимать значения:  
>> MSG_CONFIRM - Сообщить уровню связи, что процесс пересылки произошел: получен успешный ответ с другой стороны. Если уровень связи не получит его, то он будет регулярно перепроверять наличие ответной стороны.  
>> MSG_DONTROUTE - Не использовать маршрутизацию для отправки пакета, а посылать его только на узлы локальной сети. Обычно это используется в диагностических программах и программах маршрутизации.  
>> MSG_DONTWAIT - Включить неблокирующий режим.  
>> MSG_EOR - Завершить запись (record)  
>> MSG_MORE - Дополнительные данные для отправки.  
>> MSG_NOSIGNAL - Не генерировать сигнал SIGPIPE, если сторона потокоориентированного сокета закрыла соединение.  
>> MSG_OOB - Послать внепоточные данные, если сокет это поддерживает.  

5 параметр - Адрес сервера  
6 параметр - Длина адреса сервера  

При успешном выполнении эти вызовы возвращают количество отправленных байт

>> Для обмена датаграммами не нужно устанавливать соединение. Создав сокет с помощью socket и bind, его тут же можно использовать его для отправки или получения данных. Для этого вам понадобятся функции sendto (В ЭТОМ ОТЛИЧИЕ ОТ **SEND**) и recvfrom.

```
Перед вызовом функции sendto() надо заполнить структуру sockaddr (переменную srvr_name) данными об адресе сервера.  
После окончания передачи данных сокет закрывается с помощью close().
```

## int bind(int sockfd, struct sockaddr * my_addr, socklen_t addrlen);
- связывает сокет с заданным адресом (**связывать сокет с адресом необходимо в программе-сервере, но не в клиенте**)  
> bind(sock, &srvr_name, sizeof(srvr_name)) 

1 параметр - дескриптор сокета  
2 параметр - указатель на структуру sockaddr (переменная srvr_name), содержащую адрес, на котором регистрируется сервер  
3 параметр - длина структуры, содержащей адрес  

## int recvfrom(int s, void * buf, size_t len, int flags, struct sockaddr * from, socklen_t * fromlen);
- принимает данные из сокета (**по умолчанию блокирует программу до тех пор, пока на входе не появятся новые данные**)
> len = recvfrom(sock, buf, sizeof(buf), 0, NULL, NULL);

1 параметр - дескриптор сокета  
2 параметр - указатель на буфер, из которого будет производится чтение
3 параметр - число байт для чтения/записи
4 параметр -  флаги (если не нужны, то 0)
> ПРОСТО ДЛЯ ОЗНАКОМЛЕНИЯ  
>> может принимать значения:  
>> MSG_OOB запрашивает прием внепотоковых данных, которые в противном случае не были бы получены в обычном потоке данных.     
>> MSG_PEEK - выбрать данные из начала очереди, но не удалять их оттуда. Таким образом, последующий вызов функции вернет те же самые данные.   
>> MSG_WAITALL - подождать, пока не придет полное запрошенное количество данных. Однако, этот вызов все равно может вернуть меньше данных, чем было запрошено, если был пойман сигнал, произошла ошибка или разрыв соединения, или если начали поступать данные другого типа, не того, который был сначала.   
>> MSG_TRUNC - реальная длину пакета, даже если она была больше, чем предоставленный буфер.   
>> MSG_ERRQUEUE - Получить пакет из очереди ошибок.    
>> MSG_NOSIGNAL отключает возникновение сигнала SIGPIPE на потоковых сокетах, если другая сторона вдруг исчезает.  
>> MSG_ERRQUEUE - получить из очереди ошибок сокета накопившиеся ошибки.   
5 параметр -  адрес
6 параметр - указатель на переменную, в которой будет возвращена длина структуры с адресом
```
Если информация об адресе клиента не нужна, то можно передать значения NULL в предпоследнем и последнем параметрах
```

Возвращает количество принятых байт

## close & unlink
- По завершении работы с сокетом он «закрывается» с помощью «файловой» функции **close()**.  
- Перед выходом из программы-сервера следует удалить файл сокета, созданный в результате вызова socket(), что  делается с помощью функции unlink().


# 2 программа (я так думаю, на сетевые сокеты)
## struct hostent * server;
- содержит имя сервера в приемлемом для дальнейшего использования виде  
```c
struct hostent 
{
	char FAR * h_name;			// имя хоста
	char FAR * FAR * h_aliases;		// дополнительные названия
	short h_addrtype;			// тип адреса
	short h_length;			// длинна каждого адреса в байтах
	char FAR * FAR * h_addr_list;	// список адресов
};
```

##  struct sockaddr_in
- Для сетевого взаимодействия
```c
struct sockaddr_in
 { 
    short int sin_family; // Семейство адресов
    unsigned short int sin_port; // Номер порта
    struct in_addr sin_addr; // IP-адрес
    unsigned char sin_zero[8]; // Дополнение до размера структуры sockaddr
 };
```
## struct hostent * gethostbyname(const char * name);
- получает указатель на строку с Интернет-именем сервера (например, www.unix.com или 192.168.1.16)
- возвращает указатель на структуру hostent, которая содержит имя сервера в приемлемом для дальнейшего использования виде

## int connect(int sockfd, const struct sockaddr * serv_addr, socklen_t addrlen);  
- для установки соединения
1 параметр - дескриптор сокета  
> Если сокет имеет тип SOCK_DGRAM, адрес serv_addr является адресом по умолчанию, куда посылаются датаграммы, и единственным адресом, откуда они принимаются. Если сокет имеет тип SOCK_STREAM, то данный системный вызов попытается установить соединение с другим сокетом.
2 параметр - адрес, на который он ссылается   
3 параметр - длина адреса  

Если успешно, возвращается ноль.  

## ssize_t send(int s, const void * msg, size_t len, int flags);
- отправляет данные в сокет  
> send(sock, buf, strlen(buf), 0)  

1 параметр - дескриптор сокета  
2 параметр - адрес буфера для передачи данных  
3 параметр - длина буфера  
4 параметр - дополнительных флагов  

Возвращает количество отправленных символов

## fd_set
- буфер фиксированного размера  

## int fcntl(int fd, int cmd, ... / * arg * / );
- выполняет дополнительную операцию над файловым дескриптором fd. Эта операция определяется содержимым аргумента cmd.  
> fcntl(sock, F_SETFL, O_NONBLOCK);
> По умолчанию функция socket() создает **блокирующий** сокет. Чтобы сделать его **неблокирующим**, надо использовать эту функцию с флагом O_NONBLOCK. Теперь любой вызов функции read() для сокета sock будет возвращать управление сразу же. 
- F_SETFL - Устанавливает часть флагов

## Параметр INADDR_ANY
- сокет будет связан со всеми локальными интерфейсами

## uint16_t htons(uint16_t hostshort);
- преобразует узловой порядок расположения байтов положительного короткого целого hostshort в сетевой порядок расположения байтов

## int listen(int s, int backlog);  
- сообщает сокету, что должны приниматься новые соединения (задать размер очереди)
> listen(sock, NUM)
1 параметр - дескриптор сокета  
2 параметр - максимальное число соединений, которые сервер может обрабатывать одновременно

## struct timeval 
```c
struct timeval 
{
	long    tv_sec;         /* seconds */
	long    tv_usec;        /* microseconds */
};
```

## void FD_ZERO(fd_set * set);
- очищает набор

## void FD_SET(int fd, fd_set * set);
- добавляют заданный дескриптор к набору

## int FD_ISSET(int fd, fd_set * set);
- проверяет, является ли дескриптор частью набора

## int select(int nfds, fd_set * readfds, fd_set * writefds, fd_set * exceptfds, struct timeval * utimeout);
- контролировать несколько файловых дескрипторов, ожидающих, пока один или несколько файловых дескрипторов не станут доступны (готовы)  для некоторого класса операций ввода / вывода. Дескриптор файла считается готовым, если возможно выполнить
соответствующую операцию ввода / вывода 
> err = select(max_fd + 1, &set, NULL, NULL, &interval);
1 параметр - целое число, на единицу большее максимального файлового дескриптора в любом из наборов
2 параметр - набор дескрипторов (для чтения)
3 параметр - набор дескрипторов (для записи)
4 параметр - набор дескрипторов для слежения за «исключительными ситуациями»
5 параметр - задаёт наибольшее время, которое вызов select() будет ожидать событий, по прошествии которого завершит работу, даже если ничего не произойдёт. Если значение этого аргумента равно NULL, то select() будет ожидать бесконечно. Значение utimeout может быть установлено в ноль секунд; в этом случае select() возвратит управление немедленно.

```
- использует timeout представленный struct timeval (with seconds and microseconds)   
- может обновить аргумент timeout , чтобы указать сколько времени осталось  
- не имеет аргумент sigmask
```

Возвращает номер файлового дескриптора

## accept
- используется для получения нового сокета для нового входящего соединения
- устанавливает соединение в ответ на запрос клиента и создает копию сокета для того, чтобы исходный сокет мог продолжать прослушивание
- получив запрос на соединение, возвращает новый сокет, открытый для обмена данными с клиентом, запросившим соединение
> int new_sock = accept(sock, NULL, NULL);

1 параметр - дескриптор сокета  
2 параметр - сведения об адресе клиента, запросившего соединение  
3 параметр - размер  
> Последние два параметра могут быть NULL
