.386P 	;(1)Разрешение команд МП 386 и 486
;Структура для описания дескрипторов сегментов
descr	struc			;(2)
limit	dw	0			;(3)Граница (биты 0...15)
base_1 	dw	0			;(4)База, биты 0...15
base_m	db	0			;(5)База, биты 16...23
attr_1	db	0			;(6)Байт атрибутов 1
attr_2	db 	0			;(7)Граница (биты 16...19) и атрибуты 2
base_h	db	0			;(8)База, биты 24...31
descr	ends 			;(9)
data	segment			;(10)Начало сегмента данных
; Таблица глобальных дескрипторов GDT
gdt_null 	descr <0,0,0,0,0,0>	;(11)Нулевой дескриптор
gdt_data	descr <data_size-1,0,0,92h>	;(12)Селектор 8, сегмент данных
gdt_code	descr <code_size-1,,,98h>	;(13)Селектор 16, сегмент команд
gdt_stack	descr <255,0,0,92h>			;(14)Селектор 24, сегмент стека
gdt_screen	descr <4095,8000h,0Bh,92h>	;(15)Селектор 32, видеобуфер
gdt_size=$-gdt_null		;(16)Размер GDT
; Поля данных программы
pdescr	dq	0			;(17)Псевдодескриптор
sym		db	1			;(18)Символ для вывода на экран
attr 	db	1Eh			;(19)Его атрибут
mos		db	27,'[31;42m	Вернулись в реальный режим!	',27,'[0m$' ;(20)
data_size=$-gdt_null	;(21)Размер сегмента данных
data	ends			;(22)Конец сегмента данных
text	segment 'code'	use16	;(23)Укажем 16-разрядный режим
		assume CS:text, DS:data	;(24)
main	proc					;(25)
		xor		EAX,EAX			;(26)Очистим EAX
		mov 	AX,data			;(27)Загрузим в DS сегментный
		mov		DS,AX			;(28)адрес сегмента данных
;Вычислим 32-битовый линейный адрес сегмента данных и загрузим его
;в дескриптор сегмента данных в GDT.
		shl 	EAX,4			;(29)В EAX линейный базовый адрес
		mov 	EBP,EAX			;(30)Сохраним его в EBP
		mov 	BX,offset gdt_data	;(31)В BX адрес дескриптора
		mov 	[BX].base_1,AX		;(32)Загрузим младшую часть базы
		rol		EAX,16				;(33)Обмен старшей и младшей половин EAX
		mov 	[BX].base_m,AL		;(34)Загрузим среднюю часть базы
;Аналогчно для линейного адреса сегмента команд
		xor 	EAX,EAX				;(35)Очистим EAX
		mov 	AX,CS				;(36)Адрес сегмента команд
		shl		EAX, 4				;(37)Умножим на 16
		mov 	BX,offset gbt_code	;(38)Адрес дескриптора
		mov 	[BX].base_1,AX		;(39)Загрузим младшую часть базы
		rol		EAX,16				;(40)Обмен половин EAX
		mov 	[BX].base_m,AL		;(41)Загрузим среднюю часть базы
;Аналогчно для линейного адреса сегмента стека
		xor 	EAX,EAX				;(42)
		mov 	AX,SS				;(43)
		shl		EAX, 4				;(44)
		mov 	BX,offset gbt_stack	;(45)
		mov 	[BX].base_1,AX		;(46)
		rol		EAX,16				;(47)
		mov 	[BX].base_m,AL		;(48)
;Подготовим псевдодескриптор pdescr и загрузим регистр GDTR
		mov 	dword ptr pdescr+2,EBP	;(49)База GDT, биты 0...31
		mov 	word prt pdescr,gdt_size-1	;(50)Граница GDT
		lgdt	pdescr				;(51)Загрузим регистр GDTR
;Подготовимся к переводу в защищенный режим
		cli							;(52)Запрет аппаратных прерываний
		mov		AL,80h				;(53)Запрет NMI
		out 	70h,AL				;(54)Порт КМОП-микросхемы
;Переходим в защищенный режим
		mov 	EAX,CR0				;(55)Получим содержимое CR0
		or		EAX,1				;(56)Установим бит PE
		mov		CR0,EAX				;(57)Запишем назад в CR0
;Теперь процессор работает в защищённом режиме
;Загружаем в CS:IP селектор:смещение точки continue
;и заодно очищаем очередь команд
		db 		0EAh				;(58)Код команды far jmp
		dw 		offset continue		;(59)Смещение
		dw		16					;(60)Селектор сегмента команд
continue:							;(61)
;Делаем адресуемыми данные
		mov 	AX,8				;(62)Селектор сегмент данных
		mov		DS,AX				;(63)
;Делаем адресуемым стек
		mov 	AX,24				;(64)Селектор сегмента стека
		mov		SS,AX				;(65)
;Инициализируем ES и выводим символы
		mov		AX,32				;(66)Селектор сегмента видеобуфера
		mov		ES,AX				;(67)
		mov		BX,800				;(68)Начальное смещение на экране
		mov 	CX,640				;(69)Число выводимых символов
		mov		AX,word ptr sym		;(70)Начальный символ с атрибутом
screen: mov		ES:[BX],AX			;(71)Вывод в видеобуфер
		add		BX,2				;(72)Сместимся в видеобуфере
		inc 	AX					;(73)Следующий символ
		loop	screen				;(74)Цикл вывода на экран
;Подготовим переход в реальный режим
;Сформируем и загрузим дескрипторы для реального режима
		mov		gdt_data.limit,0FFFFh	;(75)Граница сегмента данных
		mov		gdt_code.limit,0FFFFh	;(76)Граница сегмента команд
		mov		gdt_stack.limit,0FFFFh	;(77)Граница сегмента стека
		mov		gdt_screen.limit,0FFFFh	;(78)Граница дополнительного сегмента
		mov		AX,8					;(79)Загрузим теневой регистр
		mov 	DS,AX					;(80)сегмента данных
		mov		AX,24					;(81)Загрузим теневой регистр
		mov 	SS,AX					;(82)стека
		mov		AX,32					;(83)Загрузим теневой регистр
		mov		ES,AX					;(84)дополнительного сегмента
;Выполним дальний переход для того, чтобы заново загрузить
;селектор в регистр CS и модифицировать его теневой регистр
		db		0EAh				;(85)Командой дальнего перехода
		dw		offset go			;(86)загрузим теневой регистр
		dw		16					;(87)сегмента команд
;Переключим режим процессора
go:		mov 	EAX,CR0				;(88)Получим содержимое CR0
		and 	EAX,0FFFFFFFEh		;(89)Сбросим бит PE
		mov		CR0,EAX				;(90)Запишем назад в CR0
		db		0EAh				;(91)Код команды far jmp
		dw		offset return		;(92)Смещение
		dw		text				;(93)Сегмент
;Теперь процессор снова работает в реальном режиме
;Восстановим операционную среду реального режима
return: mov		AX,data				;(94)Восстановим
		mov		DS,AX				;(95)адресуемость данных
		mov		AX,stk				;(96)Восстановим
		mov		SS,AX				;(97)адресуемость стека
;Разрешим аппаратные и немаскируемые прерывания
		sti							;(98)Разрешение прерываний
		mov		AL,0				;(99)Сброс бита 7 в порте CMOS - 
		out		70h,AL				;(100) - разрешение NMI
;Проверим выполнение функций DOS после возврата в реальный режим
		mov 	AH,09h				;(101)
		mov		DX,offset mos		;(102)
		int 	21h					;(103)
		mov		AX,4C00h			;(104)Завершим программу
		int		21h					;(105)обычным образом
main	endp						;(106)
code_size=$-main					;(107)Размер сегмента команд
text	ends						;(108)
stk		segment stack 'stack'		;(109)
		db		256 dup ('^')		;(110)
stk		ends						;(111)
		end		main				;(112)
